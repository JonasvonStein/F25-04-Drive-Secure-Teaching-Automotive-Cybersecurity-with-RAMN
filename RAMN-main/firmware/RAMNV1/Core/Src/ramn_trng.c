/*
 * ramn_trng.c
  ******************************************************************************
  * @attention
  *
  * <h2><center>&copy; Copyright (c) 2025 TOYOTA MOTOR CORPORATION.
  * ALL RIGHTS RESERVED.</center></h2>
  *
  * This software component is licensed by TOYOTA MOTOR CORPORATION under BSD 3-Clause license,
  * the "License"; You may not use this file except in compliance with the
  * License. You may obtain a copy of the License at:
  *                        opensource.org/licenses/BSD-3-Clause
  *
  ******************************************************************************
 */

#include "ramn_trng.h"

// RNG HAL Handle
static RNG_HandleTypeDef* pHrng;

#ifdef USE_TRNG_BUFFER
// Stream buffer automatically updated with random bytes
static StreamBufferHandle_t RandomStreamBufferHandle;

// Semaphore to enable access to TRNG module from different threads
static SemaphoreHandle_t TRNG_SEMAPHORE;
static StaticSemaphore_t TRNG_SEMAPHORE_STRUCT;
static StaticStreamBuffer_t TRNG_POOL_STRUCT;

// Static buffer that holds data from the stream buffer
static uint8_t TRNG_POOL[TRNG_POOL_SIZE];
#endif


#ifdef USE_TRNG_BUFFER
// Request module to refill the stream buffer from the TRNG peripheral
static void RNG_Refill(void)
{
	if (xStreamBufferBytesAvailable(RandomStreamBufferHandle) <= RNG_REFILL_THRESHOLD)
	{
		while (HAL_RNG_GenerateRandomNumber_IT(pHrng) != HAL_OK);
	}
}
#endif

// Exported features -----------------------------

void RAMN_RNG_Init(RNG_HandleTypeDef* handle)
{
	pHrng = handle;
#ifdef USE_TRNG_BUFFER
	RandomStreamBufferHandle    = xStreamBufferCreateStatic(TRNG_POOL_SIZE,sizeof(uint8_t),TRNG_POOL,&TRNG_POOL_STRUCT);
	TRNG_SEMAPHORE   = xSemaphoreCreateMutexStatic(&TRNG_SEMAPHORE_STRUCT);
#endif
}

#ifdef USE_TRNG_BUFFER
// Note; the "hrng" POINTER here has the same name as the "hrng" STRUCTURE defined in the global section.
// Although confusing, both are automatically generated by STM32CubeIDE and cannot easily be changed.
void HAL_RNG_ReadyDataCallback(RNG_HandleTypeDef *hrng, uint32_t random32bit)
{
	// Note that we may push more data than space is available.
	// We do not check as we do not mind losing random bytes.
	xStreamBufferSend(RandomStreamBufferHandle, (void *)&random32bit, sizeof(uint32_t),0U);
	if(xStreamBufferSpacesAvailable(RandomStreamBufferHandle) != 0)
	{
		HAL_RNG_GenerateRandomNumber_IT(hrng);
	}
}
#endif

void HAL_RNG_ErrorCallback(RNG_HandleTypeDef *hrng)
{
#ifdef HANG_ON_ERRORS
	uint32_t err = HAL_RNG_GetError(hrng);
	if (err & HAL_RNG_ERROR_TIMEOUT) 	Error_Handler();
	if (err & HAL_RNG_ERROR_BUSY) 		Error_Handler();
	if (err & HAL_RNG_ERROR_SEED) 		Error_Handler();
	if (err & HAL_RNG_ERROR_CLOCK) 		Error_Handler();
#endif
}

uint8_t RAMN_RNG_Pop8(void)
{
	uint32_t result;

#ifdef USE_TRNG_BUFFER
	RNG_Refill();
	while (xSemaphoreTake(TRNG_SEMAPHORE, portMAX_DELAY ) != pdTRUE);
	xStreamBufferReceive(RandomStreamBufferHandle,(void *)&result,sizeof(result),portMAX_DELAY);
	xSemaphoreGive(TRNG_SEMAPHORE);
#else
	HAL_RNG_GenerateRandomNumber(pHrng, &result);
#endif
	return (uint8_t)(result&0xFF);
}

uint16_t RAMN_RNG_Pop16(void)
{
	uint32_t result;

#ifdef USE_TRNG_BUFFER
	RNG_Refill();
	while (xSemaphoreTake(TRNG_SEMAPHORE, portMAX_DELAY ) != pdTRUE);
	xStreamBufferReceive(RandomStreamBufferHandle,(void *)&result,sizeof(result),portMAX_DELAY);
	xSemaphoreGive(TRNG_SEMAPHORE);
#else
	HAL_RNG_GenerateRandomNumber(pHrng, &result);
#endif
	return (uint16_t)(result&0xFFFF);
}

uint32_t RAMN_RNG_Pop32(void)
{
	uint32_t result;

#ifdef USE_TRNG_BUFFER
	RNG_Refill();
	while (xSemaphoreTake(TRNG_SEMAPHORE, portMAX_DELAY ) != pdTRUE);
	xStreamBufferReceive(RandomStreamBufferHandle,(void *)&result,sizeof(result),portMAX_DELAY);
	xSemaphoreGive(TRNG_SEMAPHORE);
#else
	HAL_RNG_GenerateRandomNumber(pHrng, &result);
#endif
	return result;
}
